/* @flow */

import { graphql } from 'graphql-compose';
import { EMCResolvers } from '../resolvers';
import { DiscriminatorTypeComposer } from './DiscriminatorTypeComposer';

const { GraphQLList, GraphQLNonNull } = graphql;

// change type on DKey generated by composeWithMongoose
// set it to created enum TypeComposer for DKey DKeyETC
// only sets on filter and record typeComposers, since they contain our DKey
function setDKeyEnumOnITCArgs(resolver, baseTC: DiscriminatorTypeComposer<any>) {
  // setDKeyEnum for filter types, and on record types
  if (resolver) {
    const argNames = resolver.getArgNames();

    for (const argName of argNames) {
      if (argName === 'filter' || argName === 'record' || argName === 'records') {
        const filterArgTC = resolver.getArgTC(argName);

        if (filterArgTC) {
          filterArgTC.extendField(baseTC.getDKey(), {
            type: baseTC.getDKeyETC(),
          });
        }
      }
    }
  }
}

// recomposing sets up the DInterface as the return types for
// Also sets up DKey enum as type for DKey field on composers with filter and/or record args
// composeWithMongoose composers
export function prepareBaseResolvers(baseTC: DiscriminatorTypeComposer<any>) {
  for (const resolverName in EMCResolvers) {
    if (EMCResolvers.hasOwnProperty(resolverName) && baseTC.hasResolver(resolverName)) {
      const resolver = baseTC.getResolver(resolverName);

      switch (resolverName) {
        case EMCResolvers.findMany:
        case EMCResolvers.findByIds:
          resolver.setType(new GraphQLList(baseTC.getDInterface().getType()));
          break;

        case EMCResolvers.findById:
        case EMCResolvers.findOne:
          resolver.setType(baseTC.getDInterface());
          break;

        case EMCResolvers.createOne:
        case EMCResolvers.updateOne:
        case EMCResolvers.updateById:
        case EMCResolvers.removeOne:
        case EMCResolvers.removeById:
          resolver.getTypeComposer().extendField('record', {
            type: baseTC.getDInterface(),
          });
          break;

        case EMCResolvers.createMany:
          resolver.getTypeComposer().extendField('records', {
            type: new GraphQLNonNull(GraphQLList(baseTC.getDInterface().getType())),
          });
          break;

        case EMCResolvers.pagination:
          resolver.getTypeComposer().extendField('items', {
            type: new GraphQLList(baseTC.getDInterface().getType()),
          });
          break;

        case EMCResolvers.connection:
          const edgesTC = resolver // eslint-disable-line no-case-declarations
            .getTypeComposer()
            .getFieldTC('edges')
            .clone(`${baseTC.getTypeName()}Edge`);

          edgesTC.extendField('node', {
            type: new GraphQLNonNull(baseTC.getDInterface().getType()),
          });

          resolver
            .getTypeComposer()
            .setField(
              'edges',
              new GraphQLNonNull(new GraphQLList(new GraphQLNonNull(edgesTC.getType())))
            );
          break;

        default:
      }

      setDKeyEnumOnITCArgs(resolver, baseTC);

      // set DKey as required field to create from base
      // must be done after setting DKeyEnum
      if (resolverName === EMCResolvers.createOne || resolverName === EMCResolvers.createMany) {
        const fieldName = resolverName === EMCResolvers.createMany ? 'records' : 'record';
        resolver.getArgTC(fieldName).extendField(baseTC.getDKey(), {
          type: baseTC.getDKeyETC().getTypeNonNull(),
        });
      }
    }
  }
}
