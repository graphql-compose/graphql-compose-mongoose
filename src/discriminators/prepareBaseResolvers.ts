import type { Resolver } from 'graphql-compose';
import { resolverFactory } from '../resolvers';
import { DiscriminatorTypeComposer } from './DiscriminatorTypeComposer';

// change type on DKey generated by composeWithMongoose
// set it to created enum ObjectTypeComposer for DKey DKeyETC
// only sets on filter and record typeComposers, since they contain our DKey
function setDKeyEnumOnITCArgs(resolver: Resolver, baseTC: DiscriminatorTypeComposer<any, any>) {
  // setDKeyEnum for filter types, and on record types
  if (resolver) {
    const argNames = resolver.getArgNames();

    for (const argName of argNames) {
      if (argName === 'filter' || argName === 'record' || argName === 'records') {
        const filterArgTC = resolver.getArgITC(argName);

        if (filterArgTC) {
          filterArgTC.extendField(baseTC.getDKey(), {
            type: baseTC.getDKeyETC(),
          });
        }
      }
    }
  }
}

// recomposing sets up the DInterface as the return types for
// Also sets up DKey enum as type for DKey field on composers with filter and/or record args
// composeWithMongoose composers
export function prepareBaseResolvers(baseTC: DiscriminatorTypeComposer<any, any>): void {
  Object.keys(resolverFactory).forEach((resolverName) => {
    if (baseTC.hasResolver(resolverName)) {
      const resolver = baseTC.getResolver(resolverName);

      switch (resolverName) {
        case 'findMany':
        case 'findByIds':
          resolver.setType(baseTC.getDInterface().List);
          resolver.projection[baseTC.getDKey()] = 1;
          break;

        case 'findById':
        case 'findOne':
          resolver.setType(baseTC.getDInterface());
          resolver.projection[baseTC.getDKey()] = 1;
          break;

        case 'createOne':
        case 'updateOne':
        case 'updateById':
        case 'removeOne':
        case 'removeById':
          resolver.getOTC().extendField('record', {
            type: baseTC.getDInterface(),
            projection: {
              [baseTC.getDKey()]: 1,
            },
          });
          break;

        case 'createMany':
          resolver.getOTC().extendField('records', {
            type: baseTC.getDInterface().List.NonNull,
            projection: {
              [baseTC.getDKey()]: 1,
            },
          });
          break;

        case 'pagination':
          resolver.getOTC().extendField('items', {
            type: baseTC.getDInterface().List,
            projection: {
              [baseTC.getDKey()]: 1,
            },
          });
          break;

        case 'connection': {
          const edgesTC = resolver
            .getOTC()
            .getFieldOTC('edges')
            .clone(`${baseTC.getTypeName()}Edge`);

          edgesTC.extendField('node', {
            type: baseTC.getDInterface().NonNull,
            projection: {
              [baseTC.getDKey()]: 1,
            },
          });

          resolver.getOTC().setField('edges', edgesTC.NonNull.List.NonNull);
          break;
        }

        default:
      }

      setDKeyEnumOnITCArgs(resolver, baseTC);

      // set DKey as required field to create from base
      // must be done after setting DKeyEnum
      if (resolverName === 'createOne' || resolverName === 'createMany') {
        const fieldName = resolverName === 'createMany' ? 'records' : 'record';
        resolver.getArgITC(fieldName).extendField(baseTC.getDKey(), {
          type: baseTC.getDKeyETC().NonNull,
        });
      }
    }
  });
}
